schema {
    query: Query
    subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

enum Aggregation_interval {
    hour
    day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

scalar Bytes

"""
8 bytes signed integer
"""
scalar Int8

type LiquidityPosition {
    id: ID!
    user: User!
    pair: Pair!
    liquidityTokenBalance: BigDecimal!
}

input LiquidityPosition_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    user: String
    user_not: String
    user_gt: String
    user_lt: String
    user_gte: String
    user_lte: String
    user_in: [String!]
    user_not_in: [String!]
    user_contains: String
    user_contains_nocase: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_: User_filter
    pair: String
    pair_not: String
    pair_gt: String
    pair_lt: String
    pair_gte: String
    pair_lte: String
    pair_in: [String!]
    pair_not_in: [String!]
    pair_contains: String
    pair_contains_nocase: String
    pair_not_contains: String
    pair_not_contains_nocase: String
    pair_starts_with: String
    pair_starts_with_nocase: String
    pair_not_starts_with: String
    pair_not_starts_with_nocase: String
    pair_ends_with: String
    pair_ends_with_nocase: String
    pair_not_ends_with: String
    pair_not_ends_with_nocase: String
    pair_: Pair_filter
    liquidityTokenBalance: BigDecimal
    liquidityTokenBalance_not: BigDecimal
    liquidityTokenBalance_gt: BigDecimal
    liquidityTokenBalance_lt: BigDecimal
    liquidityTokenBalance_gte: BigDecimal
    liquidityTokenBalance_lte: BigDecimal
    liquidityTokenBalance_in: [BigDecimal!]
    liquidityTokenBalance_not_in: [BigDecimal!]
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [LiquidityPosition_filter]
    or: [LiquidityPosition_filter]
}

enum LiquidityPosition_orderBy {
    id
    user
    user__id
    user__vrswLockedPositionsNumber
    pair
    pair__id
    pair__balance0
    pair__balance1
    pair__fee
    pair__vFee
    pair__maxReserveRatio
    pair__reserveRatio
    pair__totalSupply
    pair__blocksDelay
    pair__totalMu
    pair__totalStaked
    pair__lastSwapBlock
    pair__lastSwapTimestamp
    pair__allocationPoints
    pair__token0Price
    pair__token1Price
    pair__createdAtTimestamp
    pair__createdAtBlockNumber
    liquidityTokenBalance
}

type LpStakingPosition {
    id: ID!
    user: User!
    pair: Pair!
    amount: BigDecimal!
    mu: BigDecimal!
}

input LpStakingPosition_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    user: String
    user_not: String
    user_gt: String
    user_lt: String
    user_gte: String
    user_lte: String
    user_in: [String!]
    user_not_in: [String!]
    user_contains: String
    user_contains_nocase: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_: User_filter
    pair: String
    pair_not: String
    pair_gt: String
    pair_lt: String
    pair_gte: String
    pair_lte: String
    pair_in: [String!]
    pair_not_in: [String!]
    pair_contains: String
    pair_contains_nocase: String
    pair_not_contains: String
    pair_not_contains_nocase: String
    pair_starts_with: String
    pair_starts_with_nocase: String
    pair_not_starts_with: String
    pair_not_starts_with_nocase: String
    pair_ends_with: String
    pair_ends_with_nocase: String
    pair_not_ends_with: String
    pair_not_ends_with_nocase: String
    pair_: Pair_filter
    amount: BigDecimal
    amount_not: BigDecimal
    amount_gt: BigDecimal
    amount_lt: BigDecimal
    amount_gte: BigDecimal
    amount_lte: BigDecimal
    amount_in: [BigDecimal!]
    amount_not_in: [BigDecimal!]
    mu: BigDecimal
    mu_not: BigDecimal
    mu_gt: BigDecimal
    mu_lt: BigDecimal
    mu_gte: BigDecimal
    mu_lte: BigDecimal
    mu_in: [BigDecimal!]
    mu_not_in: [BigDecimal!]
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [LpStakingPosition_filter]
    or: [LpStakingPosition_filter]
}

enum LpStakingPosition_orderBy {
    id
    user
    user__id
    user__vrswLockedPositionsNumber
    pair
    pair__id
    pair__balance0
    pair__balance1
    pair__fee
    pair__vFee
    pair__maxReserveRatio
    pair__reserveRatio
    pair__totalSupply
    pair__blocksDelay
    pair__totalMu
    pair__totalStaked
    pair__lastSwapBlock
    pair__lastSwapTimestamp
    pair__allocationPoints
    pair__token0Price
    pair__token1Price
    pair__createdAtTimestamp
    pair__createdAtBlockNumber
    amount
    mu
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type Pair {
    id: ID!
    token0: Token!
    token1: Token!
    balance0: BigDecimal!
    balance1: BigDecimal!
    fee: BigInt!
    vFee: BigInt!
    maxReserveRatio: BigInt!
    reserveRatio: BigInt!
    totalSupply: BigDecimal!
    blocksDelay: BigInt!
    totalMu: BigDecimal!
    totalStaked: BigDecimal!
    lastSwapBlock: BigInt!
    lastSwapTimestamp: BigInt!
    whitelist(
        skip: Int = 0
        first: Int = 100
        orderBy: PairWhitelist_orderBy
        orderDirection: OrderDirection
        where: PairWhitelist_filter
    ): [PairWhitelist!]!
    allocationPoints: BigInt!
    token0Price: BigDecimal!
    token1Price: BigDecimal!
    pairReserves(
        skip: Int = 0
        first: Int = 100
        orderBy: PairReserve_orderBy
        orderDirection: OrderDirection
        where: PairReserve_filter
    ): [PairReserve!]!
    createdAtTimestamp: BigInt!
    createdAtBlockNumber: BigInt!
}

type PairReserve {
    id: ID!
    pair: Pair!
    token: Token!
    balance: BigDecimal!
    baseValue: BigDecimal!
}

input PairReserve_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    pair: String
    pair_not: String
    pair_gt: String
    pair_lt: String
    pair_gte: String
    pair_lte: String
    pair_in: [String!]
    pair_not_in: [String!]
    pair_contains: String
    pair_contains_nocase: String
    pair_not_contains: String
    pair_not_contains_nocase: String
    pair_starts_with: String
    pair_starts_with_nocase: String
    pair_not_starts_with: String
    pair_not_starts_with_nocase: String
    pair_ends_with: String
    pair_ends_with_nocase: String
    pair_not_ends_with: String
    pair_not_ends_with_nocase: String
    pair_: Pair_filter
    token: String
    token_not: String
    token_gt: String
    token_lt: String
    token_gte: String
    token_lte: String
    token_in: [String!]
    token_not_in: [String!]
    token_contains: String
    token_contains_nocase: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_: Token_filter
    balance: BigDecimal
    balance_not: BigDecimal
    balance_gt: BigDecimal
    balance_lt: BigDecimal
    balance_gte: BigDecimal
    balance_lte: BigDecimal
    balance_in: [BigDecimal!]
    balance_not_in: [BigDecimal!]
    baseValue: BigDecimal
    baseValue_not: BigDecimal
    baseValue_gt: BigDecimal
    baseValue_lt: BigDecimal
    baseValue_gte: BigDecimal
    baseValue_lte: BigDecimal
    baseValue_in: [BigDecimal!]
    baseValue_not_in: [BigDecimal!]
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [PairReserve_filter]
    or: [PairReserve_filter]
}

enum PairReserve_orderBy {
    id
    pair
    pair__id
    pair__balance0
    pair__balance1
    pair__fee
    pair__vFee
    pair__maxReserveRatio
    pair__reserveRatio
    pair__totalSupply
    pair__blocksDelay
    pair__totalMu
    pair__totalStaked
    pair__lastSwapBlock
    pair__lastSwapTimestamp
    pair__allocationPoints
    pair__token0Price
    pair__token1Price
    pair__createdAtTimestamp
    pair__createdAtBlockNumber
    token
    token__id
    token__symbol
    token__name
    token__decimals
    balance
    baseValue
}

type PairWhitelist {
    id: ID!
    token: Token!
    pair: Pair!
}

input PairWhitelist_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    token: String
    token_not: String
    token_gt: String
    token_lt: String
    token_gte: String
    token_lte: String
    token_in: [String!]
    token_not_in: [String!]
    token_contains: String
    token_contains_nocase: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_: Token_filter
    pair: String
    pair_not: String
    pair_gt: String
    pair_lt: String
    pair_gte: String
    pair_lte: String
    pair_in: [String!]
    pair_not_in: [String!]
    pair_contains: String
    pair_contains_nocase: String
    pair_not_contains: String
    pair_not_contains_nocase: String
    pair_starts_with: String
    pair_starts_with_nocase: String
    pair_not_starts_with: String
    pair_not_starts_with_nocase: String
    pair_ends_with: String
    pair_ends_with_nocase: String
    pair_not_ends_with: String
    pair_not_ends_with_nocase: String
    pair_: Pair_filter
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [PairWhitelist_filter]
    or: [PairWhitelist_filter]
}

enum PairWhitelist_orderBy {
    id
    token
    token__id
    token__symbol
    token__name
    token__decimals
    pair
    pair__id
    pair__balance0
    pair__balance1
    pair__fee
    pair__vFee
    pair__maxReserveRatio
    pair__reserveRatio
    pair__totalSupply
    pair__blocksDelay
    pair__totalMu
    pair__totalStaked
    pair__lastSwapBlock
    pair__lastSwapTimestamp
    pair__allocationPoints
    pair__token0Price
    pair__token1Price
    pair__createdAtTimestamp
    pair__createdAtBlockNumber
}

input Pair_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    token0: String
    token0_not: String
    token0_gt: String
    token0_lt: String
    token0_gte: String
    token0_lte: String
    token0_in: [String!]
    token0_not_in: [String!]
    token0_contains: String
    token0_contains_nocase: String
    token0_not_contains: String
    token0_not_contains_nocase: String
    token0_starts_with: String
    token0_starts_with_nocase: String
    token0_not_starts_with: String
    token0_not_starts_with_nocase: String
    token0_ends_with: String
    token0_ends_with_nocase: String
    token0_not_ends_with: String
    token0_not_ends_with_nocase: String
    token0_: Token_filter
    token1: String
    token1_not: String
    token1_gt: String
    token1_lt: String
    token1_gte: String
    token1_lte: String
    token1_in: [String!]
    token1_not_in: [String!]
    token1_contains: String
    token1_contains_nocase: String
    token1_not_contains: String
    token1_not_contains_nocase: String
    token1_starts_with: String
    token1_starts_with_nocase: String
    token1_not_starts_with: String
    token1_not_starts_with_nocase: String
    token1_ends_with: String
    token1_ends_with_nocase: String
    token1_not_ends_with: String
    token1_not_ends_with_nocase: String
    token1_: Token_filter
    balance0: BigDecimal
    balance0_not: BigDecimal
    balance0_gt: BigDecimal
    balance0_lt: BigDecimal
    balance0_gte: BigDecimal
    balance0_lte: BigDecimal
    balance0_in: [BigDecimal!]
    balance0_not_in: [BigDecimal!]
    balance1: BigDecimal
    balance1_not: BigDecimal
    balance1_gt: BigDecimal
    balance1_lt: BigDecimal
    balance1_gte: BigDecimal
    balance1_lte: BigDecimal
    balance1_in: [BigDecimal!]
    balance1_not_in: [BigDecimal!]
    fee: BigInt
    fee_not: BigInt
    fee_gt: BigInt
    fee_lt: BigInt
    fee_gte: BigInt
    fee_lte: BigInt
    fee_in: [BigInt!]
    fee_not_in: [BigInt!]
    vFee: BigInt
    vFee_not: BigInt
    vFee_gt: BigInt
    vFee_lt: BigInt
    vFee_gte: BigInt
    vFee_lte: BigInt
    vFee_in: [BigInt!]
    vFee_not_in: [BigInt!]
    maxReserveRatio: BigInt
    maxReserveRatio_not: BigInt
    maxReserveRatio_gt: BigInt
    maxReserveRatio_lt: BigInt
    maxReserveRatio_gte: BigInt
    maxReserveRatio_lte: BigInt
    maxReserveRatio_in: [BigInt!]
    maxReserveRatio_not_in: [BigInt!]
    reserveRatio: BigInt
    reserveRatio_not: BigInt
    reserveRatio_gt: BigInt
    reserveRatio_lt: BigInt
    reserveRatio_gte: BigInt
    reserveRatio_lte: BigInt
    reserveRatio_in: [BigInt!]
    reserveRatio_not_in: [BigInt!]
    totalSupply: BigDecimal
    totalSupply_not: BigDecimal
    totalSupply_gt: BigDecimal
    totalSupply_lt: BigDecimal
    totalSupply_gte: BigDecimal
    totalSupply_lte: BigDecimal
    totalSupply_in: [BigDecimal!]
    totalSupply_not_in: [BigDecimal!]
    blocksDelay: BigInt
    blocksDelay_not: BigInt
    blocksDelay_gt: BigInt
    blocksDelay_lt: BigInt
    blocksDelay_gte: BigInt
    blocksDelay_lte: BigInt
    blocksDelay_in: [BigInt!]
    blocksDelay_not_in: [BigInt!]
    totalMu: BigDecimal
    totalMu_not: BigDecimal
    totalMu_gt: BigDecimal
    totalMu_lt: BigDecimal
    totalMu_gte: BigDecimal
    totalMu_lte: BigDecimal
    totalMu_in: [BigDecimal!]
    totalMu_not_in: [BigDecimal!]
    totalStaked: BigDecimal
    totalStaked_not: BigDecimal
    totalStaked_gt: BigDecimal
    totalStaked_lt: BigDecimal
    totalStaked_gte: BigDecimal
    totalStaked_lte: BigDecimal
    totalStaked_in: [BigDecimal!]
    totalStaked_not_in: [BigDecimal!]
    lastSwapBlock: BigInt
    lastSwapBlock_not: BigInt
    lastSwapBlock_gt: BigInt
    lastSwapBlock_lt: BigInt
    lastSwapBlock_gte: BigInt
    lastSwapBlock_lte: BigInt
    lastSwapBlock_in: [BigInt!]
    lastSwapBlock_not_in: [BigInt!]
    lastSwapTimestamp: BigInt
    lastSwapTimestamp_not: BigInt
    lastSwapTimestamp_gt: BigInt
    lastSwapTimestamp_lt: BigInt
    lastSwapTimestamp_gte: BigInt
    lastSwapTimestamp_lte: BigInt
    lastSwapTimestamp_in: [BigInt!]
    lastSwapTimestamp_not_in: [BigInt!]
    whitelist_: PairWhitelist_filter
    allocationPoints: BigInt
    allocationPoints_not: BigInt
    allocationPoints_gt: BigInt
    allocationPoints_lt: BigInt
    allocationPoints_gte: BigInt
    allocationPoints_lte: BigInt
    allocationPoints_in: [BigInt!]
    allocationPoints_not_in: [BigInt!]
    token0Price: BigDecimal
    token0Price_not: BigDecimal
    token0Price_gt: BigDecimal
    token0Price_lt: BigDecimal
    token0Price_gte: BigDecimal
    token0Price_lte: BigDecimal
    token0Price_in: [BigDecimal!]
    token0Price_not_in: [BigDecimal!]
    token1Price: BigDecimal
    token1Price_not: BigDecimal
    token1Price_gt: BigDecimal
    token1Price_lt: BigDecimal
    token1Price_gte: BigDecimal
    token1Price_lte: BigDecimal
    token1Price_in: [BigDecimal!]
    token1Price_not_in: [BigDecimal!]
    pairReserves_: PairReserve_filter
    createdAtTimestamp: BigInt
    createdAtTimestamp_not: BigInt
    createdAtTimestamp_gt: BigInt
    createdAtTimestamp_lt: BigInt
    createdAtTimestamp_gte: BigInt
    createdAtTimestamp_lte: BigInt
    createdAtTimestamp_in: [BigInt!]
    createdAtTimestamp_not_in: [BigInt!]
    createdAtBlockNumber: BigInt
    createdAtBlockNumber_not: BigInt
    createdAtBlockNumber_gt: BigInt
    createdAtBlockNumber_lt: BigInt
    createdAtBlockNumber_gte: BigInt
    createdAtBlockNumber_lte: BigInt
    createdAtBlockNumber_in: [BigInt!]
    createdAtBlockNumber_not_in: [BigInt!]
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Pair_filter]
    or: [Pair_filter]
}

enum Pair_orderBy {
    id
    token0
    token0__id
    token0__symbol
    token0__name
    token0__decimals
    token1
    token1__id
    token1__symbol
    token1__name
    token1__decimals
    balance0
    balance1
    fee
    vFee
    maxReserveRatio
    reserveRatio
    totalSupply
    blocksDelay
    totalMu
    totalStaked
    lastSwapBlock
    lastSwapTimestamp
    whitelist
    allocationPoints
    token0Price
    token1Price
    pairReserves
    createdAtTimestamp
    createdAtBlockNumber
}

type Query {
    token(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        skip: Int = 0
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        where: Token_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Token!]!
    pair(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pair
    pairs(
        skip: Int = 0
        first: Int = 100
        orderBy: Pair_orderBy
        orderDirection: OrderDirection
        where: Pair_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Pair!]!
    user(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        skip: Int = 0
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        where: User_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [User!]!
    liquidityPosition(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LiquidityPosition
    liquidityPositions(
        skip: Int = 0
        first: Int = 100
        orderBy: LiquidityPosition_orderBy
        orderDirection: OrderDirection
        where: LiquidityPosition_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [LiquidityPosition!]!
    pairWhitelist(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PairWhitelist
    pairWhitelists(
        skip: Int = 0
        first: Int = 100
        orderBy: PairWhitelist_orderBy
        orderDirection: OrderDirection
        where: PairWhitelist_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [PairWhitelist!]!
    pairReserve(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PairReserve
    pairReserves(
        skip: Int = 0
        first: Int = 100
        orderBy: PairReserve_orderBy
        orderDirection: OrderDirection
        where: PairReserve_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [PairReserve!]!
    tokenomicsParams(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenomicsParams
    tokenomicsParams_collection(
        skip: Int = 0
        first: Int = 100
        orderBy: TokenomicsParams_orderBy
        orderDirection: OrderDirection
        where: TokenomicsParams_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [TokenomicsParams!]!
    lpStakingPosition(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LpStakingPosition
    lpStakingPositions(
        skip: Int = 0
        first: Int = 100
        orderBy: LpStakingPosition_orderBy
        orderDirection: OrderDirection
        where: LpStakingPosition_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [LpStakingPosition!]!
    vrswStakingPosition(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): VrswStakingPosition
    vrswStakingPositions(
        skip: Int = 0
        first: Int = 100
        orderBy: VrswStakingPosition_orderBy
        orderDirection: OrderDirection
        where: VrswStakingPosition_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [VrswStakingPosition!]!
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
}

type Subscription {
    token(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        skip: Int = 0
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        where: Token_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Token!]!
    pair(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pair
    pairs(
        skip: Int = 0
        first: Int = 100
        orderBy: Pair_orderBy
        orderDirection: OrderDirection
        where: Pair_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Pair!]!
    user(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        skip: Int = 0
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        where: User_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [User!]!
    liquidityPosition(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LiquidityPosition
    liquidityPositions(
        skip: Int = 0
        first: Int = 100
        orderBy: LiquidityPosition_orderBy
        orderDirection: OrderDirection
        where: LiquidityPosition_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [LiquidityPosition!]!
    pairWhitelist(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PairWhitelist
    pairWhitelists(
        skip: Int = 0
        first: Int = 100
        orderBy: PairWhitelist_orderBy
        orderDirection: OrderDirection
        where: PairWhitelist_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [PairWhitelist!]!
    pairReserve(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PairReserve
    pairReserves(
        skip: Int = 0
        first: Int = 100
        orderBy: PairReserve_orderBy
        orderDirection: OrderDirection
        where: PairReserve_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [PairReserve!]!
    tokenomicsParams(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenomicsParams
    tokenomicsParams_collection(
        skip: Int = 0
        first: Int = 100
        orderBy: TokenomicsParams_orderBy
        orderDirection: OrderDirection
        where: TokenomicsParams_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [TokenomicsParams!]!
    lpStakingPosition(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LpStakingPosition
    lpStakingPositions(
        skip: Int = 0
        first: Int = 100
        orderBy: LpStakingPosition_orderBy
        orderDirection: OrderDirection
        where: LpStakingPosition_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [LpStakingPosition!]!
    vrswStakingPosition(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): VrswStakingPosition
    vrswStakingPositions(
        skip: Int = 0
        first: Int = 100
        orderBy: VrswStakingPosition_orderBy
        orderDirection: OrderDirection
        where: VrswStakingPosition_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [VrswStakingPosition!]!
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
}

"""
A string representation of microseconds UNIX timestamp (16 digits)
"""
scalar Timestamp

type Token {
    id: ID!
    symbol: String!
    name: String!
    decimals: BigInt!
}

input Token_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    symbol: String
    symbol_not: String
    symbol_gt: String
    symbol_lt: String
    symbol_gte: String
    symbol_lte: String
    symbol_in: [String!]
    symbol_not_in: [String!]
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    name: String
    name_not: String
    name_gt: String
    name_lt: String
    name_gte: String
    name_lte: String
    name_in: [String!]
    name_not_in: [String!]
    name_contains: String
    name_contains_nocase: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    decimals: BigInt
    decimals_not: BigInt
    decimals_gt: BigInt
    decimals_lt: BigInt
    decimals_gte: BigInt
    decimals_lte: BigInt
    decimals_in: [BigInt!]
    decimals_not_in: [BigInt!]
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Token_filter]
    or: [Token_filter]
}

enum Token_orderBy {
    id
    symbol
    name
    decimals
}

type TokenomicsParams {
    id: ID!
    alpha: BigDecimal!
    beta: BigDecimal!
    gamma: BigDecimal!
    b: BigDecimal!
    r: BigDecimal!
    lpShare: BigDecimal!
    lpShareFactor: BigDecimal!
}

input TokenomicsParams_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    alpha: BigDecimal
    alpha_not: BigDecimal
    alpha_gt: BigDecimal
    alpha_lt: BigDecimal
    alpha_gte: BigDecimal
    alpha_lte: BigDecimal
    alpha_in: [BigDecimal!]
    alpha_not_in: [BigDecimal!]
    beta: BigDecimal
    beta_not: BigDecimal
    beta_gt: BigDecimal
    beta_lt: BigDecimal
    beta_gte: BigDecimal
    beta_lte: BigDecimal
    beta_in: [BigDecimal!]
    beta_not_in: [BigDecimal!]
    gamma: BigDecimal
    gamma_not: BigDecimal
    gamma_gt: BigDecimal
    gamma_lt: BigDecimal
    gamma_gte: BigDecimal
    gamma_lte: BigDecimal
    gamma_in: [BigDecimal!]
    gamma_not_in: [BigDecimal!]
    b: BigDecimal
    b_not: BigDecimal
    b_gt: BigDecimal
    b_lt: BigDecimal
    b_gte: BigDecimal
    b_lte: BigDecimal
    b_in: [BigDecimal!]
    b_not_in: [BigDecimal!]
    r: BigDecimal
    r_not: BigDecimal
    r_gt: BigDecimal
    r_lt: BigDecimal
    r_gte: BigDecimal
    r_lte: BigDecimal
    r_in: [BigDecimal!]
    r_not_in: [BigDecimal!]
    lpShare: BigDecimal
    lpShare_not: BigDecimal
    lpShare_gt: BigDecimal
    lpShare_lt: BigDecimal
    lpShare_gte: BigDecimal
    lpShare_lte: BigDecimal
    lpShare_in: [BigDecimal!]
    lpShare_not_in: [BigDecimal!]
    lpShareFactor: BigDecimal
    lpShareFactor_not: BigDecimal
    lpShareFactor_gt: BigDecimal
    lpShareFactor_lt: BigDecimal
    lpShareFactor_gte: BigDecimal
    lpShareFactor_lte: BigDecimal
    lpShareFactor_in: [BigDecimal!]
    lpShareFactor_not_in: [BigDecimal!]
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [TokenomicsParams_filter]
    or: [TokenomicsParams_filter]
}

enum TokenomicsParams_orderBy {
    id
    alpha
    beta
    gamma
    b
    r
    lpShare
    lpShareFactor
}

type User {
    id: ID!
    vrswLockedPositionsNumber: BigInt!
    liquidityPositions(
        skip: Int = 0
        first: Int = 100
        orderBy: LiquidityPosition_orderBy
        orderDirection: OrderDirection
        where: LiquidityPosition_filter
    ): [LiquidityPosition!]
    lpStakingPositions(
        skip: Int = 0
        first: Int = 100
        orderBy: LpStakingPosition_orderBy
        orderDirection: OrderDirection
        where: LpStakingPosition_filter
    ): [LpStakingPosition!]
    vrswStakingPositions(
        skip: Int = 0
        first: Int = 100
        orderBy: VrswStakingPosition_orderBy
        orderDirection: OrderDirection
        where: VrswStakingPosition_filter
    ): [VrswStakingPosition!]
}

input User_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    vrswLockedPositionsNumber: BigInt
    vrswLockedPositionsNumber_not: BigInt
    vrswLockedPositionsNumber_gt: BigInt
    vrswLockedPositionsNumber_lt: BigInt
    vrswLockedPositionsNumber_gte: BigInt
    vrswLockedPositionsNumber_lte: BigInt
    vrswLockedPositionsNumber_in: [BigInt!]
    vrswLockedPositionsNumber_not_in: [BigInt!]
    liquidityPositions_: LiquidityPosition_filter
    lpStakingPositions_: LpStakingPosition_filter
    vrswStakingPositions_: VrswStakingPosition_filter
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [User_filter]
    or: [User_filter]
}

enum User_orderBy {
    id
    vrswLockedPositionsNumber
    liquidityPositions
    lpStakingPositions
    vrswStakingPositions
}

type VrswStakingPosition {
    id: ID!
    user: User!
    amount: BigDecimal!
    lockDue: BigInt!
    discountFactor: BigDecimal!
    timestamp: BigInt!
    mu: BigDecimal!
}

input VrswStakingPosition_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    user: String
    user_not: String
    user_gt: String
    user_lt: String
    user_gte: String
    user_lte: String
    user_in: [String!]
    user_not_in: [String!]
    user_contains: String
    user_contains_nocase: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_: User_filter
    amount: BigDecimal
    amount_not: BigDecimal
    amount_gt: BigDecimal
    amount_lt: BigDecimal
    amount_gte: BigDecimal
    amount_lte: BigDecimal
    amount_in: [BigDecimal!]
    amount_not_in: [BigDecimal!]
    lockDue: BigInt
    lockDue_not: BigInt
    lockDue_gt: BigInt
    lockDue_lt: BigInt
    lockDue_gte: BigInt
    lockDue_lte: BigInt
    lockDue_in: [BigInt!]
    lockDue_not_in: [BigInt!]
    discountFactor: BigDecimal
    discountFactor_not: BigDecimal
    discountFactor_gt: BigDecimal
    discountFactor_lt: BigDecimal
    discountFactor_gte: BigDecimal
    discountFactor_lte: BigDecimal
    discountFactor_in: [BigDecimal!]
    discountFactor_not_in: [BigDecimal!]
    timestamp: BigInt
    timestamp_not: BigInt
    timestamp_gt: BigInt
    timestamp_lt: BigInt
    timestamp_gte: BigInt
    timestamp_lte: BigInt
    timestamp_in: [BigInt!]
    timestamp_not_in: [BigInt!]
    mu: BigDecimal
    mu_not: BigDecimal
    mu_gt: BigDecimal
    mu_lt: BigDecimal
    mu_gte: BigDecimal
    mu_lte: BigDecimal
    mu_in: [BigDecimal!]
    mu_not_in: [BigDecimal!]
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [VrswStakingPosition_filter]
    or: [VrswStakingPosition_filter]
}

enum VrswStakingPosition_orderBy {
    id
    user
    user__id
    user__vrswLockedPositionsNumber
    amount
    lockDue
    discountFactor
    timestamp
    mu
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes
    """
    The block number
    """
    number: Int!
    """
    Integer representation of the timestamp stored in blocks for the chain
    """
    timestamp: Int
    """
    The hash of the parent block
    """
    parentHash: Bytes
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    """
    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    """
    The deployment ID
    """
    deployment: String!
    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow
    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
